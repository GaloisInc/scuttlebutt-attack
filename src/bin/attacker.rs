#![cfg_attr(feature = "microram", no_std)]
#![cfg_attr(feature = "microram", no_main)]
use scuttlebutt_attack::attacker;
use scuttlebutt_attack::io_kernel::{self, KernelChannel};
use scuttlebutt_attack::util::ChannelPair;

#[cfg_attr(feature = "microram", no_mangle)]
pub fn main() {
    let to_server = KernelChannel::new(1);
    let from_server = KernelChannel::new(0);
    let channel = ChannelPair(to_server, from_server);
    attacker::run(channel).unwrap();
    io_kernel::exit();
}


#[no_mangle]
#[link_section = ".rodata.secret.__commitment_randomness__"]
pub static CC_COMMITMENT_RANDOMNESS: [u8; 32] = [
    // BEGIN commitment randomness
    // AUTO-GENERATED - DO NOT EDIT
    // Generated by update_commitment.py at Wed Apr 19 15:55:13 2023
    0x08, 0xdf, 0x30, 0x8a, 0x54, 0xec, 0x5d, 0x2c,
    0xcb, 0x73, 0xf8, 0x7d, 0x3c, 0x2f, 0xfb, 0x0f,
    0x7b, 0xce, 0xbd, 0xae, 0xa5, 0x4e, 0x83, 0x30,
    0xc0, 0x48, 0xa6, 0xc1, 0xad, 0x5d, 0xf2, 0xfd,
    // END commitment randomness
];


// In the native build, `__cc_syscall` dispatches directly to `kernel::syscall` with the
// appropriate `THREAD_ID`.  In the MicroRAM build, `__cc_syscall` is an intrinsic, which the
// MicroRAM compiler hooks up to the `__cc_syscall_handler` function in `bin/kernel_attacker.rs`.
#[cfg(not(feature = "microram"))]
#[no_mangle]
pub unsafe extern "C" fn __cc_syscall(num: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {
    scuttlebutt_attack::kernel::syscall::<1>(num, arg0, arg1, arg2)
}
