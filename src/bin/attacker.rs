#![cfg_attr(feature = "microram", no_std)]
#![cfg_attr(feature = "microram", no_main)]
use scuttlebutt_attack::attacker;
use scuttlebutt_attack::io_kernel::{self, KernelChannel};
use scuttlebutt_attack::util::ChannelPair;

#[cfg_attr(feature = "microram", no_mangle)]
pub fn main() {
    let to_server = KernelChannel::new(1);
    let from_server = KernelChannel::new(0);
    let channel = ChannelPair(to_server, from_server);
    attacker::run(channel).unwrap();
    io_kernel::exit();
}


#[no_mangle]
#[link_section = ".rodata.secret.__commitment_randomness__"]
pub static CC_COMMITMENT_RANDOMNESS: [u8; 32] = [
    // BEGIN commitment randomness
    // AUTO-GENERATED - DO NOT EDIT
    // Generated by update_commitment.py at Thu Apr 20 13:00:34 2023
    0x25, 0xa9, 0xcd, 0x5e, 0x37, 0xc3, 0xdc, 0xfc,
    0x13, 0xe3, 0x90, 0xf5, 0x2f, 0xce, 0xc0, 0x8c,
    0x68, 0x9a, 0xb0, 0xd6, 0x19, 0xba, 0x78, 0xcf,
    0xdd, 0x1c, 0x49, 0xd5, 0xa6, 0x48, 0x0b, 0x96,
    // END commitment randomness
];


// In the native build, `__cc_syscall` dispatches directly to `kernel::syscall` with the
// appropriate `THREAD_ID`.  In the MicroRAM build, `__cc_syscall` is an intrinsic, which the
// MicroRAM compiler hooks up to the `__cc_syscall_handler` function in `bin/kernel_attacker.rs`.
#[cfg(not(feature = "microram"))]
#[no_mangle]
pub unsafe extern "C" fn __cc_syscall(num: usize, arg0: usize, arg1: usize, arg2: usize) -> usize {
    scuttlebutt_attack::kernel::syscall::<1>(num, arg0, arg1, arg2)
}
